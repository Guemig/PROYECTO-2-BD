1. Modeling Analysis
The current Firestore structure organizes data using nested subcollections as follows: /Courses/{courseId}/Students/{studentId}/Performance/{recordId}. This structure reflects the natural relationship between courses students and their performance records. Subcollections are useful because they keep data organized enable fine-grained security rules and reduce costs by allowing segmented queries. However this structure has limitations when trying to perform global queries such as listing all students with high scores across all courses because Firestore does not support querying multiple subcollections directly. To achieve this you would need to use collectionGroup or redesign the database structure.

4. Composite Index Problem
The query that filters records with scores greater than 4.0 and sorts them by timestamp descending fails if a composite index is not defined. This happens because Firestore requires composite indexes when combining where filters with orderBy. To fix this you need to create a composite index with the fields score and timestamp in descending order through the Firebase Console. This index can only be reused if other queries use the exact same fields and sort order.
